//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.32.0
/// coordination.v1.LeaseSpec
///

import Foundation

// MARK: - coordination.v1.LeaseSpec

public extension coordination.v1 {

	///
	/// LeaseSpec is a specification of a Lease.
	///
	struct LeaseSpec: KubernetesResource {
		///
		/// acquireTime is a time when the current lease was acquired.
		///
		public var acquireTime: Date?
		///
		/// holderIdentity contains the identity of the holder of a current lease. If Coordinated Leader Election is used, the holder identity must be equal to the elected LeaseCandidate.metadata.name field.
		///
		public var holderIdentity: String?
		///
		/// leaseDurationSeconds is a duration that candidates for a lease need to wait to force acquire it. This is measured against the time of last observed renewTime.
		///
		public var leaseDurationSeconds: Int32?
		///
		/// leaseTransitions is the number of transitions of a lease between holders.
		///
		public var leaseTransitions: Int32?
		///
		/// PreferredHolder signals to a lease holder that the lease has a more optimal holder and should be given up. This field can only be set if Strategy is also set.
		///
		public var preferredHolder: String?
		///
		/// renewTime is a time when the current holder of a lease has last updated the lease.
		///
		public var renewTime: Date?
		///
		/// Strategy indicates the strategy for picking the leader for coordinated leader election. If the field is not specified, there is no active coordination for this lease. (Alpha) Using this field requires the CoordinatedLeaderElection feature gate to be enabled.
		///
		public var strategy: String?
		///
		/// Default memberwise initializer
		///
		public init(
			acquireTime: Date? = nil,
			holderIdentity: String? = nil,
			leaseDurationSeconds: Int32? = nil,
			leaseTransitions: Int32? = nil,
			preferredHolder: String? = nil,
			renewTime: Date? = nil,
			strategy: String? = nil
		) {
			self.acquireTime = acquireTime
			self.holderIdentity = holderIdentity
			self.leaseDurationSeconds = leaseDurationSeconds
			self.leaseTransitions = leaseTransitions
			self.preferredHolder = preferredHolder
			self.renewTime = renewTime
			self.strategy = strategy
		}
	}
}

///
/// Codable conformance
///
public extension coordination.v1.LeaseSpec {

	private enum CodingKeys: String, CodingKey {

		case acquireTime = "acquireTime"
		case holderIdentity = "holderIdentity"
		case leaseDurationSeconds = "leaseDurationSeconds"
		case leaseTransitions = "leaseTransitions"
		case preferredHolder = "preferredHolder"
		case renewTime = "renewTime"
		case strategy = "strategy"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.acquireTime = try container.decodeIfPresent(Date.self, forKey: .acquireTime)
		self.holderIdentity = try container.decodeIfPresent(String.self, forKey: .holderIdentity)
		self.leaseDurationSeconds = try container.decodeIfPresent(Int32.self, forKey: .leaseDurationSeconds)
		self.leaseTransitions = try container.decodeIfPresent(Int32.self, forKey: .leaseTransitions)
		self.preferredHolder = try container.decodeIfPresent(String.self, forKey: .preferredHolder)
		self.renewTime = try container.decodeIfPresent(Date.self, forKey: .renewTime)
		self.strategy = try container.decodeIfPresent(String.self, forKey: .strategy)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(acquireTime, forKey: .acquireTime)
		try encodingContainer.encode(holderIdentity, forKey: .holderIdentity)
		try encodingContainer.encode(leaseDurationSeconds, forKey: .leaseDurationSeconds)
		try encodingContainer.encode(leaseTransitions, forKey: .leaseTransitions)
		try encodingContainer.encode(preferredHolder, forKey: .preferredHolder)
		try encodingContainer.encode(renewTime, forKey: .renewTime)
		try encodingContainer.encode(strategy, forKey: .strategy)
	}
}
