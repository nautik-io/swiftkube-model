//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.33.3
/// coordination.v1beta1.LeaseCandidateSpec
///

import Foundation

// MARK: - coordination.v1beta1.LeaseCandidateSpec

public extension coordination.v1beta1 {

	///
	/// LeaseCandidateSpec is a specification of a Lease.
	///
	struct LeaseCandidateSpec: KubernetesResource {
		///
		/// BinaryVersion is the binary version. It must be in a semver format without leading `v`. This field is required.
		///
		public var binaryVersion: String
		///
		/// EmulationVersion is the emulation version. It must be in a semver format without leading `v`. EmulationVersion must be less than or equal to BinaryVersion. This field is required when strategy is "OldestEmulationVersion"
		///
		public var emulationVersion: String?
		///
		/// LeaseName is the name of the lease for which this candidate is contending. The limits on this field are the same as on Lease.name. Multiple lease candidates may reference the same Lease.name. This field is immutable.
		///
		public var leaseName: String
		///
		/// PingTime is the last time that the server has requested the LeaseCandidate to renew. It is only done during leader election to check if any LeaseCandidates have become ineligible. When PingTime is updated, the LeaseCandidate will respond by updating RenewTime.
		///
		public var pingTime: Date?
		///
		/// RenewTime is the time that the LeaseCandidate was last updated. Any time a Lease needs to do leader election, the PingTime field is updated to signal to the LeaseCandidate that they should update the RenewTime. Old LeaseCandidate objects are also garbage collected if it has been hours since the last renew. The PingTime field is updated regularly to prevent garbage collection for still active LeaseCandidates.
		///
		public var renewTime: Date?
		///
		/// Strategy is the strategy that coordinated leader election will use for picking the leader. If multiple candidates for the same Lease return different strategies, the strategy provided by the candidate with the latest BinaryVersion will be used. If there is still conflict, this is a user error and coordinated leader election will not operate the Lease until resolved.
		///
		public var strategy: String
		///
		/// Default memberwise initializer
		///
		public init(
			binaryVersion: String,
			emulationVersion: String? = nil,
			leaseName: String,
			pingTime: Date? = nil,
			renewTime: Date? = nil,
			strategy: String
		) {
			self.binaryVersion = binaryVersion
			self.emulationVersion = emulationVersion
			self.leaseName = leaseName
			self.pingTime = pingTime
			self.renewTime = renewTime
			self.strategy = strategy
		}
	}
}

///
/// Codable conformance
///
public extension coordination.v1beta1.LeaseCandidateSpec {

	private enum CodingKeys: String, CodingKey {

		case binaryVersion = "binaryVersion"
		case emulationVersion = "emulationVersion"
		case leaseName = "leaseName"
		case pingTime = "pingTime"
		case renewTime = "renewTime"
		case strategy = "strategy"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.binaryVersion = try container.decode(String.self, forKey: .binaryVersion)
		self.emulationVersion = try container.decodeIfPresent(String.self, forKey: .emulationVersion)
		self.leaseName = try container.decode(String.self, forKey: .leaseName)
		self.pingTime = try container.decodeIfPresent(Date.self, forKey: .pingTime)
		self.renewTime = try container.decodeIfPresent(Date.self, forKey: .renewTime)
		self.strategy = try container.decode(String.self, forKey: .strategy)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(binaryVersion, forKey: .binaryVersion)
		try encodingContainer.encode(emulationVersion, forKey: .emulationVersion)
		try encodingContainer.encode(leaseName, forKey: .leaseName)
		try encodingContainer.encode(pingTime, forKey: .pingTime)
		try encodingContainer.encode(renewTime, forKey: .renewTime)
		try encodingContainer.encode(strategy, forKey: .strategy)
	}
}
