//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.26.4
/// core.v1.ClaimSource
///

import Foundation

// MARK: - core.v1.ClaimSource

public extension core.v1 {

	///
	/// ClaimSource describes a reference to a ResourceClaim.
	///
	/// Exactly one of these fields should be set.  Consumers of this type must treat an empty object as if it has an unknown value.
	///
	struct ClaimSource: KubernetesResource {
		///
		/// ResourceClaimName is the name of a ResourceClaim object in the same namespace as this pod.
		///
		public var resourceClaimName: String?
		///
		/// ResourceClaimTemplateName is the name of a ResourceClaimTemplate object in the same namespace as this pod.
		///
		/// The template will be used to create a new ResourceClaim, which will be bound to this pod. When this pod is deleted, the ResourceClaim will also be deleted. The name of the ResourceClaim will be <pod name>-<resource name>, where <resource name> is the PodResourceClaim.Name. Pod validation will reject the pod if the concatenated name is not valid for a ResourceClaim (e.g. too long).
		///
		/// An existing ResourceClaim with that name that is not owned by the pod will not be used for the pod to avoid using an unrelated resource by mistake. Scheduling and pod startup are then blocked until the unrelated ResourceClaim is removed.
		///
		/// This field is immutable and no changes will be made to the corresponding ResourceClaim by the control plane after creating the ResourceClaim.
		///
		public var resourceClaimTemplateName: String?
		///
		/// Default memberwise initializer
		///
		public init(
			resourceClaimName: String? = nil,
			resourceClaimTemplateName: String? = nil
		) {
			self.resourceClaimName = resourceClaimName
			self.resourceClaimTemplateName = resourceClaimTemplateName
		}
	}
}

///
/// Codable conformance
///
public extension core.v1.ClaimSource {

	private enum CodingKeys: String, CodingKey {

		case resourceClaimName = "resourceClaimName"
		case resourceClaimTemplateName = "resourceClaimTemplateName"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.resourceClaimName = try container.decodeIfPresent(String.self, forKey: .resourceClaimName)
		self.resourceClaimTemplateName = try container.decodeIfPresent(String.self, forKey: .resourceClaimTemplateName)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(resourceClaimName, forKey: .resourceClaimName)
		try encodingContainer.encode(resourceClaimTemplateName, forKey: .resourceClaimTemplateName)
	}
}
