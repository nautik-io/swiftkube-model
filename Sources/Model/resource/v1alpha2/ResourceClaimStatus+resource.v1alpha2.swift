//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.29.6
/// resource.v1alpha2.ResourceClaimStatus
///

import Foundation

// MARK: - resource.v1alpha2.ResourceClaimStatus

public extension resource.v1alpha2 {

	///
	/// ResourceClaimStatus tracks whether the resource has been allocated and what the resulting attributes are.
	///
	struct ResourceClaimStatus: KubernetesResource {
		///
		/// Allocation is set by the resource driver once a resource or set of resources has been allocated successfully. If this is not specified, the resources have not been allocated yet.
		///
		public var allocation: resource.v1alpha2.AllocationResult?
		///
		/// DeallocationRequested indicates that a ResourceClaim is to be deallocated.
		///
		/// The driver then must deallocate this claim and reset the field together with clearing the Allocation field.
		///
		/// While DeallocationRequested is set, no new consumers may be added to ReservedFor.
		///
		public var deallocationRequested: Bool?
		///
		/// DriverName is a copy of the driver name from the ResourceClass at the time when allocation started.
		///
		public var driverName: String?
		///
		/// ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started.
		///
		/// There can be at most 32 such reservations. This may get increased in the future, but not reduced.
		///
		public var reservedFor: [resource.v1alpha2.ResourceClaimConsumerReference]?
		///
		/// Default memberwise initializer
		///
		public init(
			allocation: resource.v1alpha2.AllocationResult? = nil,
			deallocationRequested: Bool? = nil,
			driverName: String? = nil,
			reservedFor: [resource.v1alpha2.ResourceClaimConsumerReference]? = nil
		) {
			self.allocation = allocation
			self.deallocationRequested = deallocationRequested
			self.driverName = driverName
			self.reservedFor = reservedFor
		}
	}
}

///
/// Codable conformance
///
public extension resource.v1alpha2.ResourceClaimStatus {

	private enum CodingKeys: String, CodingKey {

		case allocation = "allocation"
		case deallocationRequested = "deallocationRequested"
		case driverName = "driverName"
		case reservedFor = "reservedFor"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.allocation = try container.decodeIfPresent(resource.v1alpha2.AllocationResult.self, forKey: .allocation)
		self.deallocationRequested = try container.decodeIfPresent(Bool.self, forKey: .deallocationRequested)
		self.driverName = try container.decodeIfPresent(String.self, forKey: .driverName)
		self.reservedFor = try container.decodeIfPresent([resource.v1alpha2.ResourceClaimConsumerReference].self, forKey: .reservedFor)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(allocation, forKey: .allocation)
		try encodingContainer.encode(deallocationRequested, forKey: .deallocationRequested)
		try encodingContainer.encode(driverName, forKey: .driverName)
		try encodingContainer.encode(reservedFor, forKey: .reservedFor)
	}
}
