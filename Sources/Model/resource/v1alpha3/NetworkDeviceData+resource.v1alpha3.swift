//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.33.3
/// resource.v1alpha3.NetworkDeviceData
///

import Foundation

// MARK: - resource.v1alpha3.NetworkDeviceData

public extension resource.v1alpha3 {

	///
	/// NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context.
	///
	struct NetworkDeviceData: KubernetesResource {
		///
		/// HardwareAddress represents the hardware address (e.g. MAC Address) of the device's network interface.
		///
		/// Must not be longer than 128 characters.
		///
		public var hardwareAddress: String?
		///
		/// InterfaceName specifies the name of the network interface associated with the allocated device. This might be the name of a physical or virtual network interface being configured in the pod.
		///
		/// Must not be longer than 256 characters.
		///
		public var interfaceName: String?
		///
		/// IPs lists the network addresses assigned to the device's network interface. This can include both IPv4 and IPv6 addresses. The IPs are in the CIDR notation, which includes both the address and the associated subnet mask. e.g.: "192.0.2.5/24" for IPv4 and "2001:db8::5/64" for IPv6.
		///
		/// Must not contain more than 16 entries.
		///
		public var ips: [String]?
		///
		/// Default memberwise initializer
		///
		public init(
			hardwareAddress: String? = nil,
			interfaceName: String? = nil,
			ips: [String]? = nil
		) {
			self.hardwareAddress = hardwareAddress
			self.interfaceName = interfaceName
			self.ips = ips
		}
	}
}

///
/// Codable conformance
///
public extension resource.v1alpha3.NetworkDeviceData {

	private enum CodingKeys: String, CodingKey {

		case hardwareAddress = "hardwareAddress"
		case interfaceName = "interfaceName"
		case ips = "ips"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.hardwareAddress = try container.decodeIfPresent(String.self, forKey: .hardwareAddress)
		self.interfaceName = try container.decodeIfPresent(String.self, forKey: .interfaceName)
		self.ips = try container.decodeIfPresent([String].self, forKey: .ips)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(hardwareAddress, forKey: .hardwareAddress)
		try encodingContainer.encode(interfaceName, forKey: .interfaceName)
		try encodingContainer.encode(ips, forKey: .ips)
	}
}
