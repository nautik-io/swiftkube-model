//
// Copyright 2020 Swiftkube Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///
/// Generated by Swiftkube:ModelGen
/// Kubernetes v1.33.3
/// resource.v1alpha3.AllocatedDeviceStatus
///

import Foundation

// MARK: - resource.v1alpha3.AllocatedDeviceStatus

public extension resource.v1alpha3 {

	///
	/// AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.
	///
	struct AllocatedDeviceStatus: KubernetesResource {
		///
		/// Conditions contains the latest observation of the device's state. If the device has been configured according to the class and claim config references, the `Ready` condition should be True.
		///
		/// Must not contain more than 8 entries.
		///
		public var conditions: [meta.v1.Condition]?
		///
		/// Data contains arbitrary driver-specific data.
		///
		/// The length of the raw data must be smaller or equal to 10 Ki.
		///
		public var data: JSONObject?
		///
		/// Device references one device instance via its name in the driver's resource pool. It must be a DNS label.
		///
		public var device: String
		///
		/// Driver specifies the name of the DRA driver whose kubelet plugin should be invoked to process the allocation once the claim is needed on a node.
		///
		/// Must be a DNS subdomain and should end with a DNS domain owned by the vendor of the driver.
		///
		public var driver: String
		///
		/// NetworkData contains network-related information specific to the device.
		///
		public var networkData: resource.v1alpha3.NetworkDeviceData?
		///
		/// This name together with the driver name and the device name field identify which device was allocated (`<driver name>/<pool name>/<device name>`).
		///
		/// Must not be longer than 253 characters and may contain one or more DNS sub-domains separated by slashes.
		///
		public var pool: String
		///
		/// Default memberwise initializer
		///
		public init(
			conditions: [meta.v1.Condition]? = nil,
			data: JSONObject? = nil,
			device: String,
			driver: String,
			networkData: resource.v1alpha3.NetworkDeviceData? = nil,
			pool: String
		) {
			self.conditions = conditions
			self.data = data
			self.device = device
			self.driver = driver
			self.networkData = networkData
			self.pool = pool
		}
	}
}

///
/// Codable conformance
///
public extension resource.v1alpha3.AllocatedDeviceStatus {

	private enum CodingKeys: String, CodingKey {

		case conditions = "conditions"
		case data = "data"
		case device = "device"
		case driver = "driver"
		case networkData = "networkData"
		case pool = "pool"
	}

	init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		self.conditions = try container.decodeIfPresent([meta.v1.Condition].self, forKey: .conditions)
		self.data = try container.decodeIfPresent(JSONObject.self, forKey: .data)
		self.device = try container.decode(String.self, forKey: .device)
		self.driver = try container.decode(String.self, forKey: .driver)
		self.networkData = try container.decodeIfPresent(resource.v1alpha3.NetworkDeviceData.self, forKey: .networkData)
		self.pool = try container.decode(String.self, forKey: .pool)
	}

	func encode(to encoder: Encoder) throws {
		var encodingContainer = encoder.container(keyedBy: CodingKeys.self)

		try encodingContainer.encode(conditions, forKey: .conditions)
		try encodingContainer.encode(data, forKey: .data)
		try encodingContainer.encode(device, forKey: .device)
		try encodingContainer.encode(driver, forKey: .driver)
		try encodingContainer.encode(networkData, forKey: .networkData)
		try encodingContainer.encode(pool, forKey: .pool)
	}
}
